Homework : John is happy


constants of type e : a b c j m
constants of type <e,et> : love'


variables of type e : x-z
variables of type <e,t> : P-Q X-Z
variables of type <e,et> : R-W
variables of type <et,t> : V B



multiple letter identifiers


use rule function application
use rule non-branching nodes
use rule predicate modification
use rule lambda abstraction


define John1 : j
define John2 : LP.[P(j)]
define happy : Lx.happy(x)
define happy2 : LV.[V(Lx.happy(x))]
define loves : Lx. Ly.love(y,x)
define loves2 : Lx.LV.[V(Ly.love(y,x))]
define loves3 : LB.LV.[B(Lx.[V(Ly.love(y,x)))]]
define Mary : m
define Mary2 : LQ.[Q(m)]


LB.LV.[B(Lx.[V(Ly.love(y,x)))]] (LQ.[Q(m)])
LV.[LQ.[Q(m)](Lx.[V(Ly.love(y,x))])]
LV.[[Lx.[V(Ly.love(y,x))](m)]]
LV.[V(Ly.love(y,m))]

λV.[V(λy.love(y,m))]

[λV.[V(λy.love(y,m))]](λP.[P(j)])
[λP.[P(j)](λy.love(y,m))]
λy.love(y,m))(j)
love(j,m)


exercise tree
title John is happy
directions Do the derivation.

[.S [.NP John1 ] [.VP (is)  happy ] ]
[.S [.NP John2 ] [.VP (is) happy2 ] ]

exercise tree
title John loves Mary
directions Do the derivation.

[.S [.NP John1] [.VP [.V loves]  [.NP Mary] ] ]
[.S [.NP John2] [.VP [.V loves2]  [.NP Mary] ] ]
[.S [.NP John2] [.VP [.V loves3]  [.NP Mary2] ] ]
